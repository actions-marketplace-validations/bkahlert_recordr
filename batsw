#!/usr/bin/env bash
#
# Bats wrapper that transparently delegates calls to an
# ad-hoc built Docker image containing Bats.
#
# Advantages:
# - no installation necessary
# - further functionality easily addable

set -Eeuo pipefail

# echo wrapper that allows to suppress output.
# Globals:
#   BATSW_QUIET - if set, suppresses output
# Arguments:
#   None
echo() {
  [ "${BATSW_QUIET-}" ] || printf '%s\n' "$*" >&2
}

# Prints the specified message and exits with exit code 1.
#
# Globals:
#   none
# Arguments:
#   * - echo arguments
die() {
  printf ' %s %s\n' "$(tput setaf 1)‚úò$(tput sgr0)" "$*" >&2
  exit 1
}

# Splits the specified variable to an array like it would be the case if a program was called,
# that is, its value is word-split along the whitespaces while *honoring* quotes.
# Arguments:
#   1 - variable name
split_to_array() {
  # Assigns the arguments array to the variable with the name of the first element.
  program() { eval "$1"='("${@:2}")'; }
  [ ! -v "$1" ] || eval program "$1" "${!1}"
  [ -v "$1" ] || eval "declare -a -g $1=()"
  unset program
}

# Bakes a new Docker image
#
# Arguments:
#   * - `docker buildx bake` arguments
# Outputs:
#   STDOUT - image ID
#   STDERR - build progress
bake_local() {
  echo "üê≥ building Docker image:" "$@"
  if ! docker buildx bake "$@"; then
    die "failed to bake Docker image"
  fi
  docker images --format='{{.ID}}' | head -1
}

# Returns a Docker entrypoint Bash script that fixes Docker socket permissions
# and drops its root permissions before continuing execution.
#
# The parameters `puid` and `pgid` have to be set before persisting this script,
# e.g. using `sed`.
#
# Globals:
#   none
# Arguments:
#  None
entrypoint_script() {
  cat <<'ENTRYPOINT'
#!/usr/bin/env bash
set -uo pipefail
if [ "${BATSW_INJECT-}" ]; then
  inject_path=${BATSW_INJECT%%=*}
  [ "${inject_path:0:1}" = "/" ] || inject_path="/opt/bats/${inject_path}"
  inject_content=${BATSW_INJECT#*=}
  inject_dir=${inject_path%/*}
  mkdir -p "$inject_dir"
  printf '%s\n' "$inject_content" > "$inject_path"
fi
declare -r \
puid= # set during docker build
declare -r \
pgid= # set during docker build
# get ownership; on Linux being Docker group member would be sufficient
# but on macOS the mounted socket is always root:root
chown -R "${puid:?}:${pgid:?}" /var/run/docker.sock 2>/dev/null || true
# drop permissions
yasu "${puid}:${pgid}" "$@"
ENTRYPOINT
}

# Builds a Bats docker container and returns its image ID.
# All arguments are passed unchanged to `docker build`.
#
# According to http://lists.busybox.net/pipermail/busybox/2004-January/044642.html
# busybox's sed is a "fully compatible sed implementation", but unfortunately
# it's not (https://lists.uclibc.org/pipermail/uclibc-cvs/2012-January/030044.html).
# Therefore GNU's sed will be also installed.
#
# Globals:
#   none
# Arguments:
#   * - docker build arguments
docker_build() {
  DOCKER_BUILDKIT=1 \
    DOCKER_SCAN_SUGGEST=false \
    docker build \
    --quiet \
    --build-arg ENTRYPOINT_SCRIPT="$(entrypoint_script)" \
    "$@" - <<'DOCKERFILE'
FROM bats/bats
RUN mkdir -p /opt
RUN apk \
    --no-cache \
    --update \
    add \
    bash \
    curl \
    expect \
    git \
    jq \
    shadow \
    sed \
    openssh-client \
    sshpass
RUN set -eu; \
  \
  arch="$(uname -m)"; \
  case "$arch" in \
    # amd64
    x86_64) dockerArch='x86_64' ;; \
    # arm32v6
    armhf) dockerArch='armel' ;; \
    # arm32v7
    armv7|armv7l) dockerArch='armhf' ;; \
    # arm64v8
    aarch64) dockerArch='aarch64' ;; \
    # ppc64le
    ppc64le) dockerArch='ppc64le' ;; \
    # s390x
    s390x) dockerArch='s390x' ;; \
    *) echo >&2 "error: unsupported architecture ($arch)"; exit 1 ;;\
  esac; \
  \
  if ! curl -LfsSo docker.tgz "https://download.docker.com/linux/static/stable/${dockerArch}/docker-18.06.3-ce.tgz"; then \
    echo >&2 "error: failed to download 'docker-18.06.3-ce.tgz' from 'stable' for '${dockerArch}'"; \
    exit 1; \
  fi; \
  \
  tar --extract \
      --file docker.tgz \
      --strip-components 1 \
      --directory /usr/local/bin/ \
  ; \
  rm docker.tgz; \
  \
  docker --version
ARG PUID=1000
ARG PGID=1000
ARG ENTRYPOINT_SCRIPT
RUN git clone https://github.com/bats-core/bats-support.git /opt/bats-support \
 && git clone https://github.com/bats-core/bats-assert.git /opt/bats-assert \
 && git clone https://github.com/bats-core/bats-file.git /opt/bats-file \
 && find /opt/bats-*/ -type d -name "test" -exec rm -rf {} + \
 && ln -s /opt/bats_load_lib /usr/local/bin/load_lib \
 && mkdir -p /usr/local/sbin \
 && echo "${ENTRYPOINT_SCRIPT}" > /usr/local/sbin/entrypoint.sh \
 && sed -i -e "s/^puid.*/puid=${PUID}/" -e "s/^pgid.*/pgid=${PGID}/" /usr/local/sbin/entrypoint.sh \
 && chmod +x /usr/local/sbin/entrypoint.sh
# groupadd/useradd must be used instead of addgroup/adduser
# as on hosts like macOS IDs can be outside of the typical range 0..256000
RUN groupadd \
    --gid $PGID \
    tester
RUN useradd \
    --comment "app user" \
    --uid $PUID \
    --gid tester \
    --shell /bin/bash \
    --home-dir /home/tester \
    tester \
 && mkdir -p /home/tester \
 && chown -R tester:tester /home/tester \
 && chmod 711 /home/tester
COPY --from=crazymax/yasu:1.17.0 / /
ENTRYPOINT ["/tini", "--", "entrypoint.sh", "bash", "bats"]
DOCKERFILE
}

# Run the specified tests using an ad-hoc built Docker image containing Bats.
# Includes bash-support, bash-assert, bash-file and a Docker CLI.
#
# Globals:
#   TERM - used to determine the terminal capabilities
#   PWD - the current working directory
#   BATSW_IMAGE - image containing Bats (default: bkahlert/batsw:$BATSW_IMAGE_TAG)
#   BATSW_IMAGE_TAG - locally built Bats Docker image (default: latest)
#   BATS_TMPDIR - base temporary directory used by Bats
# Arguments:
#   * - docker run arguments
# bashsupport disable=BP2001,BP5006
bats() {
  local -a args=() batsw_args=()
  while (($#)); do
    case $1 in
      --batsw:*)
        batsw_args+=("${1#--batsw:}")
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done
  set -- "${args[@]}"

  local -a opts=()
  opts+=("-e" "TESTING=1")
  opts+=("-e" "RECORDING=${RECORDING-}")
  opts+=("-e" "TERM=${TERM-}")
  opts+=("-e" "TMPDIR=$PWD/${BATS_TMPDIR%$PWD}")

  # Adds the given arguments to the opts array
  opts() { eval 'opts+=("$@")'; }
  [ ! -t 0 ] || opts+=("--interactive")
  [ ! -t 1 ] || [ ! -t 2 ] || [ "${TERM-}" = dumb ] || opts+=("--tty")
  [ ! -v BATSW_ARGS ] || eval opts "$BATSW_ARGS"
  opts+=("${batsw_args[@]}")
  opts+=("--rm")
  opts+=("--name" "${0##*/}--$(head /dev/urandom | LC_ALL=C.UTF-8 tr -dc A-Za-z0-9 2>/dev/null | head -c 3)")
  opts+=("${BATSW_IMAGE:-bkahlert/batsw:${BATSW_IMAGE_TAG:-latest}}")

  local -a bats_opts=()
  bats_opts+=("--jobs" "$(nproc 2>/dev/null || echo 4)")
  bats_opts+=("--no-parallelize-within-files")
  bats_opts+=("--recursive")
  bats_opts+=("--timing")

  opts+=("${bats_opts[@]+"${bats_opts[@]}"}")

  local -a bats_args=("${bats_opts[@]+"${bats_opts[@]}"}" "$@")
  echo "$(tput setaf 7) ‚Ñπ$(tput sgr0) bats command line: bats" "${bats_args[@]+"${bats_args[@]}"}"
  docker run \
    -e DEBUG="${DEBUG-}" \
    -e TZ="$(date +"%Z")" \
    -e PUID="$(id -u)" \
    -e PGID="$(id -g)" \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v "$PWD":"$PWD" \
    -w "$PWD" \
    "${opts[@]+"${opts[@]}"}" \
    "$@"
}

# If `BATSW_IMAGE` is not set, builds an image locally
# and sets `BATSW_IMAGE` to it.
# Globals:
#   BATSW_IMAGE - image containing Bats (default: built ad-hoc)
#   BATSW_LOCAL_IMAGE - locally built Bats Docker image (default: batsw:local)
#   BATS_TMPDIR - base temporary directory used by Bats
# Arguments:
#   * - docker run arguments
ensure_image() {
  if [ "${BATSW_IMAGE-}" ]; then
    echo "üê≥ re-using existing Bats Docker image: $BATSW_IMAGE"
    return 0
  fi

  local local_image="${BATSW_LOCAL_IMAGE:-batsw:local}"
  if BATSW_IMAGE=$(
    docker_build \
      --tag "$local_image" \
      --build-arg PUID="$(id -u)" \
      --build-arg PGID="$(id -g)"
  ); then
    export BATSW_IMAGE
    echo "üê≥ using built Bats Docker image: $BATSW_IMAGE"
  elif [ "$(docker image ls --quiet "$local_image")" ]; then
    BATSW_IMAGE="$local_image"
    export BATSW_IMAGE
    echo " $(tput setaf 11)!$(tput sgr0) failed to build Bats Docker image; re-using previous build: $BATSW_IMAGE"
  else
    die "Failed to build Bats Docker image and no previous build to re-use"
  fi
}

# Prepares the Bats environment and
# runs the specified tests using the included Bats wrapper.
#
# Globals:
#   TERM - used to determine the terminal capabilities
#   BATS_TMPDIR - base temporary directory used by Bats (default: build/bats-tmp)
#   BATSW_QUIET - if set, suppresses any output related to the wrapper
#   DOCKER_BAKE - if set, its value is passed to `docker buildx bake` (example: DOCKER_BAKE=--set=*.tags=test)
# Arguments:
#   inject - format: foo=bar; creates a file at location foo with the contents of bar inside the Docker image
#   quiet  - see BATSW_QUIET
#   *      - bats arguments
# bashsupport disable=BP2001,BP5006
main() {
  TERM=${TERM:-dumb}
  export TERM
  local -r BATS_CMD=bats

  local -a BATS_ARGS=()
  while (($#)); do
    case "$1" in
      --inject)
        [ "${2-}" ] || die "value of inject missing"
        BATS_ARGS+=("--batsw:--env" "--batsw:BATSW_INJECT=$2")
        shift 2
        ;;
      --quiet)
        export BATSW_QUIET=1
        shift
        ;;
      -o | --output)
        if [ "${2-}" ] && [ "${2:0:1}" != "-" ]; then
          mkdir -p "$2"
          BATS_ARGS+=("$1" "$2")
          shift 2
        else
          [ "${2-}" ] || die "value of $1 missing"
        fi
        ;;
      *)
        BATS_ARGS+=("$1")
        shift
        ;;
    esac
  done

  [ "${BATS_TMPDIR-}" ] || export BATS_TMPDIR="build/bats-tmp"
  [ ! -e "$BATS_TMPDIR" ] || rm -rf -- "$BATS_TMPDIR"
  [ -e "$BATS_TMPDIR" ] || mkdir -p "$BATS_TMPDIR" || die "'$BATS_TMPDIR' could not be created"
  # shellcheck disable=SC2064
  trap "rmdir '$BATS_TMPDIR' &>/dev/null || true" EXIT # delete if empty on exit

  echo "$(tput setaf 2)‚ñ∂‚ñ∂$(tput sgr0) $(tput bold)TEST RUN$(tput sgr0)"
  echo "$(tput setaf 7) ‚Ñπ$(tput sgr0) working directory: $PWD"
  echo "$(tput setaf 7) ‚Ñπ$(tput sgr0) batsw command line:" "$BATS_CMD" "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}"

  if [ "${DOCKER_BAKE-}" ]; then
    split_to_array DOCKER_BAKE
    baked_tag="$(bake_local "${DOCKER_BAKE[@]+"${DOCKER_BAKE[@]}"}")"
    echo "üê≥ built Docker image: $baked_tag"
  fi

  ensure_image

  # Checks for tests starting with capital X.
  # If such exist, focus on them and ignore the others.
  local highlighted_tests_args=('--filter' '^[Xx]')
  local highlighted_tests=0
  if ! highlighted_tests=$(TERM=dumb "$BATS_CMD" --count "${highlighted_tests_args[@]}" "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}"); then
    echo "Failed to find highlighted tests"
  fi

  if [ "$highlighted_tests" = "0" ]; then
    "$BATS_CMD" "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}"
  else
    "$BATS_CMD" "${highlighted_tests_args[@]}" "--no-tempdir-cleanup" "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}"
  fi
}

main "$@"
